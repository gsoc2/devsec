/*
 * Wazuh Vulnerability Detection Module Configuration
 * Copyright (C) 2015, Wazuh Inc.
 * August 31, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef CLIENT
#ifndef WIN32
#include "wazuh_modules/wmodules.h"

/* Global variables */
int wm_vulnerability_detection_subnode_read(const OS_XML *xml, XML_NODE nodes, cJSON *output_json)
{
    int i;
    xml_node **children;
    cJSON * subnode;
    cJSON * existing_item;
    cJSON * array_item;

    if (!nodes)
        return 0;

    // Iterate over elements
    for (i = 0; nodes[i]; i++) {
        if((children = OS_GetElementsbyNode(xml, nodes[i])))
        {
            subnode = cJSON_CreateObject();
            wm_vulnerability_detection_subnode_read(xml, children, subnode);
            cJSON_AddItemToObject(output_json, nodes[i]->element, subnode);
            OS_ClearNode(children);
        }
        else
        {
            if((existing_item = cJSON_GetObjectItem(output_json, nodes[i]->element)))
            {
                // Already exists a key in JSON with this same name at this level
                if(cJSON_IsArray(existing_item))
                {
                    // Item already is an array. Just add the new item to array
                    cJSON_AddItemToArray(existing_item, cJSON_CreateString(nodes[i]->content));
                }
                else
                {
                    // Item is not an array. Convert existing item to array and then add the new item to it
                    existing_item = cJSON_DetachItemFromObject(output_json, nodes[i]->element);
                    array_item = cJSON_AddArrayToObject(output_json, nodes[i]->element);
                    cJSON_AddItemToArray(array_item, cJSON_CreateString(cJSON_GetStringValue(existing_item)));
                    cJSON_AddItemToArray(array_item, cJSON_CreateString(nodes[i]->content));
                    cJSON_Delete(existing_item);
                }
            }
            else
            {
                cJSON_AddStringToObject(output_json, nodes[i]->element, nodes[i]->content);
            }
        }
    }

    return 0;
}

int Read_Vulnerability_Detection(const OS_XML *xml, XML_NODE nodes, void *d1)
{
    wmodule **wmodules = (wmodule**)d1;
    wmodule *cur_wmodule = NULL;
    wmodule *cur_wmodule_exists;
    wm_vulnerability_scanner_t *vulnerability_scanner = NULL;

    // Allocate memory
    if (*wmodules) {
        cur_wmodule_exists = *wmodules;

        while (cur_wmodule_exists) {
            if(cur_wmodule_exists->tag) {
                if(strcmp(cur_wmodule_exists->tag, WM_VULNERABILITY_SCANNER_CONTEXT.name) == 0) {
                    cur_wmodule = cur_wmodule_exists;
                    break;
                }
            }

            if (cur_wmodule_exists->next == NULL) {
                os_calloc(1, sizeof(wmodule), cur_wmodule_exists->next);
                cur_wmodule = cur_wmodule_exists->next;
                cur_wmodule->context = &WM_VULNERABILITY_SCANNER_CONTEXT;
                cur_wmodule->tag = strdup(cur_wmodule->context->name);

                os_calloc(1, sizeof(wm_vulnerability_scanner_t), vulnerability_scanner);
                vulnerability_scanner->vulnerability_detection = cJSON_CreateObject();
                cur_wmodule->data = vulnerability_scanner;

                break;
            }

            cur_wmodule_exists = cur_wmodule_exists->next;
        }
    } else {
        os_calloc(1, sizeof(wmodule), cur_wmodule);
        *wmodules = cur_wmodule;
        cur_wmodule->context = &WM_VULNERABILITY_SCANNER_CONTEXT;
        cur_wmodule->tag = strdup(cur_wmodule->context->name);

        os_calloc(1, sizeof(wm_vulnerability_scanner_t), vulnerability_scanner);
        vulnerability_scanner->vulnerability_detection = cJSON_CreateObject();
        cur_wmodule->data = vulnerability_scanner;
    }

    if (!cur_wmodule) {
        merror(MEM_ERROR, errno, strerror(errno));
        return OS_INVALID;
    }

    if (!nodes) {
        mdebug1("Empty configuration for module '%s'", cur_wmodule->context->name);
        return 0;
    }

    vulnerability_scanner = (wm_vulnerability_scanner_t *)cur_wmodule->data;

    if (wm_vulnerability_detection_subnode_read(xml, nodes, vulnerability_scanner->vulnerability_detection) < 0) {
        return OS_INVALID;
    }

    return 0;
}

#endif
#endif
